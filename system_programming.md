
# Системное программирование

Системное программирование похоже на управление «движком» компьютера: здесь важны не кнопки и интерфейсы, а механизмы работы «под капотом». Давайте подробно разберём ключевые темы, объясняя сложные термины простыми словами и раскрывая все нюансы.

## 1. Операционная система: роль и структура

**Операционная система (ОС)** — это программный посредник между аппаратным обеспечением и пользовательскими приложениями. Представьте, что железо — это сцена театра, а приложения — актёры. ОС же – режиссёр, который распределяет роли, следит за расписанием и обеспечивает взаимодействие между участниками.

### Компоненты ОС

1. **Ядро (kernel)**
Сердце ОС, работающее в привилегированном режиме (то есть с полным доступом к ресурсам). Обрабатывает системные вызовы, управляет памятью и процессами.
2. **Драйверы устройств**
Специальные модули, переводящие обобщённые команды ОС в конкретные инструкции для «железа» (например, как диску читать блоки или видеокарте отображать кадры).
3. **Системные службы (демоны)**
Фоновые процессы, выполняющие задачи: обслуживание сетевых подключений, планирование заданий, журналирование событий. Они стартуют вместе с системой и работают постоянно.
4. **Оболочки и утилиты**
Консольная или графическая оболочка (shell), в которой вы вводите команды, и вспомогательные программы (файловые менеджеры, текстовые редакторы).

### Монолитное ядро vs микроядро

- **Монолитное ядро**
Включает драйверы и службы в одном адресном пространстве.
    - Плюсы: быстрота обмена между компонентами.
    - Минусы: ошибка в одном модуле может привести к сбою всей системы.
- **Микроядро**
В ядре остаются только базовые функции (планировщик задач, передача сообщений), а драйверы и службы работают как обычные процессы в пользовательском пространстве.
    - Плюсы: надёжность — сбой одного драйвера не «упадёт» всё ядро.
    - Минусы: больше переключений между пространствами, небольшие задержки.


### Пространства пользователя и ядра

- **Пространство ядра** — область, где код работает с полными правами, может напрямую обращаться к оборудованию и всем ресурсам.
- **Пользовательское пространство** — ограниченная область, где работают приложения, чтобы случайная ошибка не «сломала» всю систему.
Переход из пространства пользователя в пространство ядра осуществляется через **системные вызовы** (system calls), например `read` или `write`.

***

## 2. Языки и инструменты системного программирования

### Языки

- **C**
Минимальная абстракция над «железом», прямой доступ к памяти через указатели.
- **C++**
Добавляет объектно-ориентированные концепции и шаблоны, но сохраняет контроль над памятью.
- **Ассемблер**
Пишется под конкретную архитектуру (x86, ARM), позволяет оптимизировать самые критичные участки.
- **Nim**
Генерирует чистый C-код, сочетая удобство высокоуровневого синтаксиса и контроль указателей через `ptr` и `cast`.


### Инструменты

- **Компиляторы (gcc, clang)**
Переводят код в машинные инструкции, поддерживают оптимизации (ключи `-O2`, `-O3`).
- **Отладчики (gdb, lldb)**
Позволяют запускать программу шаг за шагом, устанавливать точки останова (breakpoints), смотреть содержимое регистров и памяти.
- **Профилировщики (perf, Valgrind)**
Измеряют, где программа тратит больше всего времени (hot spots) и ищут утечки памяти.

***

## 3. Управление памятью: детали и нюансы

### Области памяти процесса

1. **Стек (stack)**
Хранит локальные переменные и параметры функций. Быстрый доступ, но фиксированный размер, риск переполнения (stack overflow).
2. **Куча (heap)**
Динамическая память через `malloc`/`free` (в C) или `new`/`delete` (в C++). Гибкая, но требует внимательного управления, иначе появляются **утечки памяти** (memory leaks).
3. **Статические сегменты**
Глобальные и статические переменные, инициализированные при запуске.

### Виртуальная память и страницы

Каждый процесс получает виртуальный адресный пространство, разделённое на **страницы** (обычно по 4 КБ). Аппаратная часть (Memory Management Unit, MMU) переводит виртуальные адреса в физические через **таблицы страниц**. ОС может «выгружать» неактивные страницы на диск (swap), что позволяет запускать больше процессов, чем поместилось бы в RAM.

### Mmap и файловый ввод-вывод

С помощью **mmap** можно отобразить файл в адресное пространство процесса, обращаясь к его содержимому как к обычному массиву в памяти. Это удобно для работы с большими данными и организует **межпроцессное взаимодействие** (shared memory).

### Безопасность памяти

- **ASLR (Address Space Layout Randomization)**
«Перемешивает» базовые адреса областей памяти, чтобы затруднить эксплуатацию уязвимостей.
- **NX/DEP (No-eXecute/Data Execution Prevention)**
Позволяет пометить область памяти как «только для данных», запрещая выполнение кода из неё.
- **Safe functions**
Вместо небезопасных `strcpy` и `sprintf` использовать `strncpy`, `snprintf`, чтобы избежать **переполнения буфера**.

***

## 4. Процессы и потоки: как ОС делит ресурсы

### Процессы

Процесс — независимый исполнитель с собственным адресным пространством и PID (Process ID). ОС планирует выполнение процессов по алгоритмам: **round-robin** (каждому по очереди) или **priority-based** (учитывая приоритеты), а в Linux — гибридный **CFS (Completely Fair Scheduler)**, который старается равномерно распределить время процессора.

### Потоки

Поток (thread) — «веточка» внутри процесса, разделяющая с ним память, но имеющая собственный стек и контекст (регистры). Потоки облегчают параллельную работу, но приводят к сложностям:

- **Условия гонки (race conditions)**
Возникают, когда два потока одновременно читают и записывают одну переменную, что может привести к непредсказуемым результатам.
- **Синхронизация**
    - **Мьютекс (mutex)** — блокировка для одного потока, остальные ждут освобождения.
    - **Семафор** — даёт возможность нескольким потокам зайти в критическую секцию (counting semaphore).
    - **Условная переменная (condition variable)** — поток может ждать события, пока другой поток не посигналит о наступлении этого события.

*Аналогия*: несколько работников (потоки) в одной мастерской (процесс): они разделяют инструменты и материалы, поэтому нужно договориться, кто и когда что использует.

***

## 5. Ввод-вывод: обеспечение скорости и масштабируемости

### Блокирующий и неблокирующий I/O

- **Блокирующий I/O** (`read`, `write`) — процесс ждёт завершения операции и не выполняет ничего другого.
- **Неблокирующий I/O** (флаг O_NONBLOCK) — система сразу возвращает управление, указывая, готовы ли данные.
- **Multiplexing** (`select`, `poll`, `epoll`) — позволяет одному потоку обслуживать множество соединений, проверяя их готовность.
- **Асинхронный I/O (AIO)**
ОС сама уведомляет программу о завершении операции: через **сигнал** или **событие**. Это называется **асинхронным вызовом** и устраняет необходимость постоянного опроса (polling).

***

## 6. Файловые системы и FUSE

### Структура файловой системы

1. **Суперблок** — общая информация: размер ФС, статус, точки монтирования.
2. **Inode** — метаданные каждого файла: права доступа, владелец, указатели на блоки данных.
3. **Блоки данных** — фиксированного размера участки диска, где хранится контент файлов.

### FUSE (Filesystem in Userspace)

Позволяет создавать собственные файловые системы в пользовательском пространстве без прав ядра. Это удобно для экспериментов: виртуальные ФС для шифрования, сетевых хранилищ или тестирования алгоритмов распределения блоков.

***

## 7. Драйверы устройств: взаимодействие с аппаратурой

**Драйвер** — это код, напрямую общающийся с аппаратурой. В его задачу входит:

1. **Инициализация**
Настройка портов ввода-вывода, выделение ресурсов (IRQ, DMA-каналов).
2. **Обработка прерываний (IRQ)**
Когда устройство хочет «привлечь внимание» CPU, оно шлёт **аппаратное прерывание**. ОС переключается на обработчик прерываний драйвера, чтобы быстро отреагировать.
3. **DMA (Direct Memory Access)**
Позволяет устройству напрямую читать и записывать в память, минуя CPU, что снижает нагрузку и ускоряет копирование больших объёмов данных.
4. **Завершение работы**
Освобождение ресурсов и деинициализация перед выгрузкой драйвера.

Разработка драйвера требует знания архитектуры шины (PCI, USB), модели прерываний и правил привилегий ядра.

***

## 8. Сетевое программирование: протоколы и сокеты

Сеть строится по модели из четырёх уровней:

1. **Канальный и физический уровни** (Ethernet, Wi-Fi)
2. **Сетевой уровень** (IP-протокол)
3. **Транспортный уровень**
    - **TCP** (надёжный, устанавливает соединение, гарантирует доставку в правильном порядке).
    - **UDP** (быстрый, без предварительного «рукопожатия», не гарантирует доставку).
4. **Прикладной уровень** (HTTP, FTP, DNS).

### Сокеты

- **BSD-sockets API** — классический интерфейс для работы с сетью.
- **Raw-сокеты** — дают доступ к «голому» сетевому пакету, используются для написания собственных протоколов или сетевых утилит (ping, traceroute).

Для высоконагруженных серверов важны неблокирующие сокеты и мультиплексирование (**epoll** в Linux), чтобы один поток мог одновременно обслужить тысячи клиентов.

***

## 9. Отладка, анализ и обеспечение качества

### Отладка

- **gdb/LLDB** — устанавливают **breakpoints**, позволяют пошагово выполнять код, просматривать значения переменных и содержимое памяти.
- **strace** — показывает все **системные вызовы** процесса, что помогает понять, какие файлы он открывает и какие сетевые соединения устанавливает.
- **ltrace** — аналогично strace, но для библиотечных вызовов.


### Профилирование

- **perf** — аппаратные счётчики CPU (счёт кеш-промахов, тактов), выявляет «горячие» участки кода.
- **Valgrind (Memcheck)** — инструмент, обнаруживающий **утечки памяти**, неверные обращения к неинициализированным данным и выходы за границы буфера.


### Качество кода

- **Code Review**
Процесс, когда коллеги анализируют ваш код перед слиянием в основную ветку. Коллеги комментируют стиль, архитектуру, ищут ошибки и уязвимости. Код-ревью снижает количество багов и улучшает читаемость.
- **Статический анализ**
Инструменты вроде **cppcheck**, **Coverity** сканируют исходники без запуска, находят потенциальные ошибки, утечки и нарушения стиля.
- **Фаззинг (fuzzing)**
Автоматическая подача «случайных» или специально модифицированных входных данных для выявления сбоев и уязвимостей. Популярный фреймворк **AFL (American Fuzzy Lop)** генерирует мутационные тесты и отслеживает нестандартные пути исполнения.

***

## 10. Обеспечение безопасности на системном уровне

1. **Принцип наименьших привилегий**
Запускайте службы и демоны с минимально необходимыми правами, чтобы потенциальный взлом ограничивался одним модулем.
2. **Аппаратные защиты**
    - ASLR и DEP (описаны выше).
    - **SMEP/SMAP** — защита от исполнения команд из пользовательской памяти.
3. **Регулярное обновление**
Патчи ядра и библиотек закрывают известные уязвимости.
4. **Фаззинг и Code Review**
Постоянное тестирование и анализ кода для выявления ошибок до релиза.

***

### Итоги

Системное программирование — это сочетание глубокого понимания внутренней архитектуры компьютера, тщательного управления ресурсами и строгих практик обеспечения надёжности и безопасности. Последовательное изучение каждой темы, от основ ОС до продвинутых техник анализа и защиты, позволит освоить эту непростую, но крайне увлекательную область.

